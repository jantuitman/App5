function documentation()
{
   this.listeners=[];
   this.data= [{
      "title":"Welcome to App5",
      "text":"Welcome to App5. App5 is a javascript library for making Apps/ GUI's.\u000aApps can be:\u000a\u000a- iphone Apps\u000a- iPad Apps\u000a- web browser Apps\u000a\u000aSee this \"youtube demonstration\":(http://www.youtube.com/watch?v=TrIyEHIzrwg)\u000a\u000aYou can write just javascript! The library will do a lot of gui work for you: it will look like an iphone app on your iPhone, and in the browser it will look good too. This documentation site is written in App5.\u000a\u000aApp5 applications are highly structured in a model/view/controller/component like way. This is gives a clear structure to your code. You can put reusable HTML inside components and reuse them over more than one project.\u000a\u000aApp5 is licensed under the Creative Commons Attribution 3.0 license. So it's free to use!\u000a\u000aApp5 is currently finished for 90% (that explains the rough edges you are seeing right now ;-). Keep checking out this site for updates."
   },
   {
      "title":"Supported devices",
      "text":"App5 is supported in the the following desktop browsers (currently):\u000a\u000a|  IE | not supported |\u000a| Firefox | supported |\u000a| Safari | supported |\u000a| Google chrome | works apparently? support coming soon  |\u000a| Opera | status unknown. not supported |\u000a\u000aThe following mobile scenarios are working:\u000a\u000a| iPhone/iPod web browser | supported |\u000a| iPhone embedded (using PhoneGap) | supported |\u000a| iPad (simulator) web browser | supported |\u000a| iPad(simulator) embedded | support coming soon |\u000a\u000aOther phone OS'es are not supported yet. \u000a"
   },
   {
      "title":"Concepts",
      "text":"",
      "children":[{
            "title":"Handling resolutions",
            "text":"App5 is a framework for browsers on desktop computers, for the large touch screen of the ipad, and of course also for the small screen of the iphone.\u000a\u000aTherefore App5 provides some instruments to make your app work on a variety of resolutions.\u000aYou start the app by main.js and in that script you can specify which resolutions your app supports:\u000a\u000a<<<\u000a\u000avar settings= { \u000a\u0009layout: ....\u000a       ,\u0009renderStyle: App5.RS_LARGE\u000a       ,        preferred_sizes: [\u000a         \u0009{ minX: 800 , minY: 1,  width:600, height: 500 , sidebar: 200  },\u000a\u0009        { minX: 1200, minY: 1,  width:900, height: 500 , sidebar: 275  }\u000a       ]\u000a\u0009, mode: \"debug\"\u0009\u000a};\u000a\u000a\u000a$(document).ready(function() {\u000a\u0009\u000a     \u0009App5.runApplication(\"App5Documentation\",\"documentation\",settings);\u000a})\u000a\u000a>>>\u000a\u000athe renderStyle property can have the values App5.RS_SMALL or App5.RS_LARGE. On the iPhone the renderStyle property is ignored and the app is allways rendered in the style RS_SMALL (which makes sense because the screen is not large enough for more, anyways).\u000a\u000aThe difference between the small and the large renderstyle is the possibility to include a sidebar in the view. The render style also is used to determine which views and controllers App5 load. If you call ``App5.pushView('notes',....) this will load the view notes.xml if the renderstyle is RS_SMALL. However, it will load the view notes_large.xml if the renderStyle is RS_LARGE.\u000aThe associated controller javascript file must also have a different name for the small and the large style. In this way, one application can support different devices and resolutions. \u000a\u000aThe preferred sizes property is an array containing objects that describe how the App should be rendered at different window sizes.\u000aThe minX,minY properties are compared with the window size and the last (highest) matching object is selected. The selected object determines the width and height of the App5 frame, as well as the width of the sidebar."
         },
         {
            "title":"Views",
            "text":"A view in App5 is an xml file that defines the layout of several components. A view can be loaded and displayed, either full screen or as a modal overlay (modal overlay currently is not yet implemented.)\u000a\u000aEach view has a controller, which is a javascript file, which has the same name as the view itself. The controller contains eventhandling functions for the view.\u000a\u000aTo load a view: use ``App5.pushView(viewName,params,viewMode)``. The viewName is a string which contains (part of) the name of the xml file that contains the view definition. It is a part, because for different screen resolutions a postfix sometimes is appended. See .... for details.\u000aThe ``params`` parameter is an object that contains data that will be passed to the ``on_show`` method of the controller.\u000aThe ``viewMode`` defines the type of the view (normal, or modal overlay).\u000a\u000aAn example of an xml file for a view: \u000a\u000a<<<\u000a<a5_screen>\u000a\u0009<a5_header title=\"overview\">\u000a             <a5_button id=\"addButton\" label=\"add\" />\u000a        </a5_header>\u000a\u0009<a5_body scrollwrapping=\"true\">\u000a\u0009\u0009<a5_list id=\"mylist\" arrows=\"true\"/>\u000a\u0009</a5_body>\u000a\u0009<a5_footer></a5_footer>\u000a</a5_screen>\u000a>>>\u000a\u000aThe view allways must contain a root tag called ``a5_screen``. (It would be nice if we could also load other parts but for now screens and views are tightly coupled). The tags correspond with components, so the ``<a5_screen>`` tag will create an a5_screen component. \u000aEach component can define the subtags that are allowed, so an ``a5_screen`` can have subtags ``a5_header`` and ``a5_body`` and ``a5_footer`` but not, for instance``a5_form``.\u000a\u000a\u000a++API\u000a\u000aAPI calls that correspond with views:\u000a\u000a| App5.pushView | shows a new view on the screen |\u000a| App5.popView   | closes the current view                |\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a"
         },
         {
            "title":"Controllers",
            "text":"A controller is a javascript object which handles events for views. Controllers have the same name as views and are loaded whenever a call to ``App5.pushView`` is being made. Controller code looks like this:\u000a\u000a<<<\u000aApp5.Controller('notes',{\u000a    \u000a    models: ['notes']    \u000a    ,\u000a    \u000a    onload: function(success,failure) {\u000a\u0009}\u000a\u0009,\u000a    ....\u000a\u0009\u0009\u000a});\u000a>>>\u000a\u000aThe controller is created by calling ``App5.Controller`` with a name parameter and an object containing all the functions and other properties for this controller.\u000a\u000aThe controller contains a property called ``models`` which is an array and tells which models need to be loaded before this controller can be run.\u000a\u000aThe names of the functions that a controller contains, follow certain conventions so that App5 knows which events have to be sent to which function. An event handler for a global event is called ``on<eventname>``, like the ``onload`` function in the controller. There are also events associated with components, and for those events the function should be called ``on<eventname>_<componentid>`` : like for example ``onclick_button1`` which would define the onclick handler for a component called button1.\u000a\u000a++API\u000a\u000aApp5 controllers don't define important public API calls.\u000a \u000a"
         },
         {
            "title":"Components",
            "text":"App5 Components are javascript classes that can be instantiated from the view's xml.\u000aApp5 Components define their own meta data: which attributes they have, which child components they have. This describes which nodes and attributes must be present in the xml for this component.\u000a\u000aApp5 Components are also responsible for rendering (part of) the screen, and for handling some of the events generated by their own html.\u000aA component can choose to handle the event itself or to leave the event handling to the controller.\u000a\u000a++Metadata \u000a\u000aMetadata of components is declared in the constructor function of the component.  The constructor of a component should look like this:\u000a\u000a<<<\u000afunction a5_body(id)\u000a{\u000a\u0009this.id=id;\u000a\u0009this.name='a5_body';\u000a\u0009this.childType='unordered';\u000a\u0009this.childsAllowed=['a5_buttonmenu','a5_html','a5_list','a5_form','a5_wiki','a5_panel'];\u000a\u0009this.children=[];\u000a\u0009this.attributeDefinitions=[{ name:'scrollwrapping'}];\u000a\u0009this.attributes={};\u000a\u000a        ....\u000a\u0009\u000a\u0009this.isAreaObject=true;\u000a}\u000a>>>\u000a\u000athe constructor get passed in a param called ``id`` which is the id of the component. A component should declare its own name in the ``.name`` property.\u000a \u000aThe ``childType`` property declares which child components this component can have. Possible values are : #text, unordered, sequence. If childType is #text, the component can have a text node as child. If childType is 'unordered' the nodes allowed are any nodes that are specified in the childsAllowed array. If childType is 'sequence' the childsAllowed array contains the node names which must be the child nodes in that specific order. In that case, node names may be followed by a question mark to denote that these are optional nodes. So for example:\u000a\u000a<<<\u000athis.name='a5_parent'\u000athis.childType='sequence'\u000athis.childsAllowed=['a5_a?','a5_b','a5_c?','a5_d']\u000a>>>\u000a\u000awill allow the following xml in the view:\u000a\u000a<<<\u000a<a5_parent>\u000a  <a5_b />\u000a  <a5_c />\u000a  <a5_d />\u000a</a5_parent>\u000a\u000a>>>\u000a\u000aThe ``attributeDefinitions`` property of a component contains a list of objects, each with a ``name`` property. These names define the names of attributes that are allowed on the xml tag of this component.\u000a\u000aThe ``isAreaObject`` defines if this component can supply a width and a height for a rectangular area. Child components can call ``getAreaObject`` to find the first parent with a defined width and height, and can use the width and height for rendering.\u000a\u000a++Rendering\u000a\u000aAll components should implement the following methods:\u000a\u000a| render(arr) |  push the initial html code of this component into the array.  |\u000a| update()     |  called whenever the component must update.                     |\u000a\u000aThe render method is called on first load, and also called when a large portion of the screen is rerendered. Update is called whenever this component must update, and the html is already in place. The component can then find the html and update it via DOM methods. Or, replace the entire html with new html and use the render method of child components to generate this html.\u000a\u000a++ API\u000a\u000a| getAttribute | gets the value of an attribute | \u000a| setAttribute | sets the value of an attribute |\u000a| getKeyPath | gets the keypath that this component uses to query its model |\u000a| setKeyPath | sets the keypath that this component uses to query its model |\u000a| getParentObject | finds an ancestor component with a specified name |\u000a| getChildObject | searches children for a component with a specified name |\u000a| getAreaObject | finds the area defining ancestor of this component |\u000a| output | takes a string and produces an escaped html string |\u000a| sendEventToController | use this to pass events to the controller |\u000a"
         },
         {
            "title":"Models",
            "text":"A Model in App5 is a javascript class that is responsible for storing data. Each model resides in a javascript file inside the models folder.\u000aThis script (for example: notes.js) can be loaded by a call to App5.loadModel('notes',success,failure) where success and failure are callback functions (one of them is executed after loading the model script).\u000a\u000aBecause models will be loaded quite often, controllers can define a property called models, the value of which is an array of strings, declaring which models are needed for this controller. The script files will then be loaded automatically, and the instance of the model is returned (in the controller) whenever the controller calls ``App5.getModel('notes')``.\u000a\u000aSo what happens inside a model? The default App5 model class wraps a json object, which can be accessed by the .data property of the model instance.\u000aWhenever a value is changed in the data property, the .update() method should be called on the model. This notifies components that listen to this model to update their contents.\u000a\u000aIt also saves the json object into HTML5 local storage. (If debug is enabled, the json object will not be saved). The next time when the model is loaded, its data object will be retrieved from the storage.\u000a\u000aBy this way, models provide a very easy way of persistent data to your app. You don't need a server or an ajax call! But if you want to sync the object via AJAX or (in an embedded situation) with an objective C model, this is also possible.\u000a\u000a",
            "children":[{
                  "title":"Syncing a model over HTTP"
               },
               {
                  "title":"Syncing a model with objective C"
               }
            ]
         }
      ]
   },
   {
      "title":"App5 in the browser"
   },
   {
      "title":"Making native apps"
   },
   {
      "title":"Download",
      "text":"You can download a zip file or git clone the source from \"github\":(http://github.com/jantuitman/App5)\u000a\u000a"
   },
   {
      "title":"API Docs"
   },
   {
      "title":"FAQ"
   }
]
}

documentation.prototype=new App5Model();


//App5.models['documentation']=documentation;